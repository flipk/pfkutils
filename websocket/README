
websocket-demo
==============

This code is for demo purposes only. It shows how to work a websocket.

There's a C++ component (WebSocketServer) for the server side.  It
handles accepting new connections, spawning threads to handle them,
and the parsing and generating of websocket packets.  There's a
javascript component for passing these messages back and forth.

Google Protobufs are used for all encoding and decoding.  Protobufs
(C++) are available from code.google.com/p/protobuf.  The client side
uses three projects from dcodeIO on github:

https://github.com/dcodeIO/Long.js
https://github.com/dcodeIO/ByteBuffer.js
https://github.com/dcodeIO/ProtoBuf.js

The messages are defined in pfkchat.proto.  'protoc' from
protobuf-2.5.0 was used to generate pfkchat.pb.cc and .h on the server
side.  'proto2js' command from the 'protobufjs' package (installable
using 'npm') in the Node.js environment is used to convert
pfkchat.proto to pfkchat.js.  This is then read on the client side to
provide message definitions to the js code.

The client-side is in test.html, test.css, and the javscript code to
implement the client-side chat is in test.js.  test.js uses services
from ProtoBuf.js, which internally uses services from ByteBuffer.js
and Long.js.

The WebSocket* files are intended to be a stand-alone library for
server-side of websockets.

The server-side main and chat handler code is in testWebSocketServer.cc.

WARNING
=======

This code is NOT production quality! It is so full of holes you could
drive a nigerian scammer through it. Do not deploy on a production
server!  You will be screwed so hard! I warned you.

This code is full of unchecked return values, hard-coded maximum
buffer sizes without size checking; there's no authentication or
encryption support; and there's no mechanism for load-shedding if the
server should become overloaded.  This is merely a proof-of-concept
showing what APIs are required to use web sockets from javascript and C++.
