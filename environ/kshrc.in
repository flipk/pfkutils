###########################################################################
#
#      Last update: 2015-03-30.12:20:08
#
#  ATTENTION READER OF THIS FILE
#
#  I do something funny.  ITS does not have the shell I like to use.
#  I like to use pfksh, which is ksh plus useful features, such as
#  the command history and tab completion you expect in a shell, but
#  with all the nifty 'sh' or 'ksh' features like functions and
#  file-descriptor numbers specified for redirects.
#
#  I have therefore built pfksh in my own directory. But I cannot just
#  change my account's login shell to point to a file in my homedir,
#  because if it turns out that my nfs fileserver for my homedir is down,
#  then I can't login.
#
#  So I do something funny. My login shell is /bin/ksh which is present
#  on all ITS machines if nfs servers are up or down. This script then
#  attempts to locate my pfksh binary and if it is found, it is then exec'd.
#  From that point on on that machine, $SHELL points to my home dir.
#
#  But this is really gross, so if you're going to take things from this
#  file I advise extreme caution in making your account work like mine.
#  I perfected this on my home unix machine before bringing it here, 
#  because it took some time to get it right.
#
#  If you have questions about this file I'll be happy to answer them
#  if I find the time.               -- Phil Knaack
#
#############################################################################

#
# always ensure this file is specified as ENV.
#

USER=@PFK_USER_NAME@
REALUSER=`id -u -n`
HOME=/home/$USER
ENV=$HOME/.kshrc
HOST=`hostname`
HOST=${HOST%%\.*}
TMP=/tmp/$USER
TMPDIR=$TMP
TEMP=$TMP
USERID=@PFK_USER_ID@
GROUP=@PFK_GROUP_ID@

if [ ! -d $TMP ] ; then
    mkdir -p $TMP
    chmod 700 $TMP
fi

export USER HOME ENV HOST TMP TMPDIR TEMP REALUSER
 
if [ -f $HOME/.verbose ] ; then
       __verbose() {
               echo $$ $*
               echo `hostname` `tty` `date` $$ $* >> $HOME/.verbose
       }
else
       __verbose() {
               return 0
       }
fi

__verbose 0=$0 RUN_CCS=$RUN_CCS GOOD_SHELL=$GOOD_SHELL SHELL=$SHELL HOST=$HOST options=$- args=$*

# if this is a login shell, unset these vars to make sure
# they get regenerated.

case $- in 
    *i*)
       __noninteractive() {
               return 1
       }
       ;;
    *)
       __noninteractive() {
               return 0
       }
       ;;
esac

case $- in 
    *l*)
        unset ENV_SET
        ;;
esac

if [ -z "$KSH_VERSION" ] ; then
    __isksh() {
        return 1
    }
else
    __isksh() {
        return 0
    }
fi

if __isksh ; then
    if [[ x$LAST_HOST != x$HOST ]] ; then
        __verbose from $LAST_HOST to $HOST, regen ENV
        unset ENV_SET
    fi
    if [[ x$LOGIN_LOGGED == x ]] ; then
        REMOTE_HOST=${SSH_CONNECTION%% *}
        __verbose logging REMOTE_HOST=$REMOTE_HOST to lastlog
        echo `hostname` `date` pid $$ term $TERM from $REMOTE_HOST >> .lastlog
        export LOGIN_LOGGED=yes REMOTE_HOST
    fi
else
    if [ x$LAST_HOST != x$HOST ] ; then
        __verbose from $LAST_HOST to $HOST, regen ENV
        unset ENV_SET
    fi
fi

LAST_HOST=$HOST
export LAST_HOST

if __isksh ; then
    if [[ x$PFKARCH == x ]] ; then
        PFKARCH=`@prefix@/bin/architecture`
        export PFKARCH
    fi
else
    PFKARCH=`@prefix@/bin/architecture`
    export PFKARCH
fi

__verbose PFKARCH=$PFKARCH

#
# convoluted way to set the path. this works
# regardless of which platform this runs on.
#

case x$ENV_SET in 
    x)
        if __isksh ; then
            __extend_path() {
                if [[ -d $1 ]] ; then
                    if [[ x$p = x ]] ; then
                        p=$1
                    else
                        p=$p:$1
                    fi
                fi
            }
        else
            __extend_path() {
                if [ -d $1 ] ; then
                    if [ x$p = x ] ; then
                        p=$1
                    else
                        p=$p:$1
                    fi
                fi
            }
        fi

        p=''
        __extend_path @prefix@/$PFKARCH/bin
        __extend_path @prefix@/bin
        __extend_path ~/bin
        __extend_path /usr/bin/X11
        __extend_path /usr/misc/X11/bin
        __extend_path /usr/misc/GNU/bin
        __extend_path /opt/site/bin
        __extend_path /opt/local/bin
        __extend_path /opt/gnu/bin
        __extend_path /usr/X11R6/bin
        __extend_path /usr/openwin/bin
        __extend_path /opt/X11R6.4/bin
        __extend_path /usr/misc/bin
        __extend_path /usr/vendor/bin
        __extend_path /usr/atria/bin
        __extend_path /usr/mot/bin
        __extend_path /apps/public/bin
        __extend_path /usr/local/bin
        __extend_path /usr/local/wmplayer
        __extend_path /usr/local/X11
        __extend_path /usr/ucb
        __extend_path /usr/etc
        __extend_path /usr/dt/bin
        __extend_path /usr/ccs/bin
        __extend_path /bin
        __extend_path /usr/bin
        __extend_path /usr/lib
        __extend_path /sbin
        __extend_path /usr/sbin
        __extend_path /share/scripts
        __extend_path /share/bin
        __extend_path /share/pd/bin
        __extend_path /motorola/bin
        __extend_path /opt/SUNWspro/bin
        __extend_path /usr/vendor/hst/1.0/bin
        __extend_path /usr/vendor/lb/3.3/bin.sol4
        __extend_path /open_source/bin-sun/gcc/bin
        __extend_path /usr/public/sphinx/ITS/IDE

        unset -f __extend_path

        PATH=$p
        ENV_SET=yes
        unset p
    
        export PATH ENV_SET

        __verbose PATH=$PATH

        ;;
esac

# reverse mode : rev or mr      \E[7m
# exit attributes: sgr0 or me   \E[m

if __isksh ; then
    _set_prompt_first_time=1
    TTY=`tty`
    TTY=${TTY#/dev/}

    _set_prompt() {
        typeset _ps
        _ps=''
        if [[ "x$1" != x ]] ; then
            _ps="${_ps}[7m$1[m
"
        fi
        _ps="${_ps}$REALUSER@$HOST"
        if [[ x$CLEARCASE_ROOT != x ]] ; then
            _ps="${_ps} in CMBP"
        fi
        if [[ "x$WIND_BASE" != x ]] ; then
            _ps="${_ps} in ${WIND_BASE##*/}"
        fi
        _ps="${_ps} pid $$ on $TTY"
        if [[ x$WINDOW != x ]] ; then
            _ps="${_ps}, scr $STY-$WINDOW"
        fi
        if [[ $_set_prompt_first_time -eq 1 ]] ; then
            _ps="${_ps}
 % "
            _set_prompt_first_time=0
        else
            _ps="${_ps}
 [7m%[m "
        fi
        export PS1="$_ps"
    }

else

    _set_prompt() {
        export PS1="$1 % "
    }

fi

export LANG=C
export EDITOR=vi
export VISUAL=vi
export VIEWER=xless
export CSCOPE_EDITOR=$HOME/bin/ec
export NPCL_EDITOR=less
export PAGER=less
export  LESS='-j5 -c -d -h 5 -i -M -q -S -n -e -R'
export XLESS='-j5 -c -d -h 5 -i -M -q -R'
export BLOCKSIZE=1024
export WGFILE=$TMP/wg.$USER

# for some reason setting HISTSIZE resets the set -o emacs option!

export HISTSIZE=250

#
# fix up TERM to make it sane.
#

case $TERM in
    xterm|xterms|linux|screen|rmhost-*)
        TERM=vt100
        ;;
    cygwin)
        TERM=vt100
        stty rows 24 cols 80
        ;;
esac
export TERM

#
# aliases go here
#

alias h='fc -l'
alias s=screen
alias res='eval `resize -u`'
alias ls='ls -F'
alias xl=xless
alias l=less
alias lt='l -n +G'
alias zl='zcat \!* | less'
alias zt='l -n +G ~/.messages'
alias p='rm -f *~'
alias ed='echo export DISPLAY=$DISPLAY'
alias mem='top -n 1 | grep ^Mem'
alias cdc='cd $HOME;clear'
alias pfkman='MANPATH=$HOME/pfk/share/man man'
alias setdate='date "+date %m%d%H%M%Y.%S"'
alias gitlog='git log --decorate=full --parents --graph'

#FUNCTIONS: make_file_part x xr xs xrs xsd xsd2 sd sd2 xless z ediff merge3 myemacs cvsd2 d1 d2 d3

make_file_part() {
    typeset try dir_part file_part fp load
    fp="$1"

    if [[ -L "$fp/.base" ]] ; then
        dir_part="${fp%/*/*}"
        load="${fp##$dir_part/}"
        print $2=\"[$load]\"
        return
    fi

    if [[ -f .backpath ]] ; then
        typeset base
        base=`awk '/^BASE/ { print $2 }' .backpath`
        base=`command cd "$base" ; pwd`
        if [[ -d "$base/load" ]] ; then
            base="$base/load"
        fi
        dir_part="${base%/*/*}"
        load="${base##$dir_part/}"
        try="${fp##$base/}"
        print $2="[$load]:$try"
        return
    fi

    case $fp in 

        /usr/vob/*)
            try=${fp#/usr/vob/}
            typeset vobname
            vobname=${try%%/*}
            try=${try#$vobname/}
            if [[ "x$CLEARCASE_ROOT" == x ]] ; then
                print $2="[$vobname]:${try#/}"
            else
                print $2="${try#/}"
            fi
            ;;

        /view/*/usr/vob/*)
            typeset viewname
            try=${fp#/view/}
            viewname=${try%%/*}
            try=${fp#/view/*/usr/vob/}
            vobname=${try%%/*}
            try=${try#$vobname/}
            print $2="[$viewname]:${try#/}"
            ;;

        *)
            dir_part="${fp%/*/*/*/*/*}"
            file_part="${fp##$dir_part}"
            file_part="${file_part#/}"
            if [[ "x$file_part" = x || "x$dir_part" = x ]] ; then
                file_part="$PWD"
            fi
            print $2=\"$file_part\"
            ;;

    esac

}

emacsn() {
    if [ $# -lt 1 ] ; then
        echo usage: emacsn NUMBER files
        return
    fi
    export EMACS_NUMBER=$1
    export EMACSCLIENT_SOCKET=/tmp/$USER/emacs-$EMACS_NUMBER/server
    shift
    emacs $* &
    return
}

echodate() {
    while true ; do
        date
        random_hex 70
        sleep 60
    done
}

x() {
    if [[ $# -eq 0 ]] ; then
        xterm &
    else
        xterm -e $* &
    fi
}

xr() {
    if [[ $# -eq 0 ]] ; then
        xterm -name knaack_xterm &
    else
        xterm -name knaack_xterm -e $* &
    fi
}

xs() {
    if [[ $# -eq 0 ]] ; then
        xterm -name XTermScreen &
    else
        xterm -name XTermScreen -e $* &
    fi
}

xrs() {
    if [[ $# -eq 0 ]] ; then
        xterm -name knaack_xterm_screen &
    else
        xterm -name knaack_xterm_screen -e $* &
    fi
}

diffheight=50

xsd() {
    xterm +sb -title NoTitle -g 190x${diffheight}+0+20 -e $SHELL -c "sd $1 $2" &
}

xsd2() {
    xterm +sb -title NoTitle -g 190x${diffheight}+0+20 -e $SHELL -c "sd2 $1 $2" &
}

d() {
    xsd2 $1.orig $1
}

sd() {
    typeset cols
    cols=`stty size 2>/dev/null | awk '{print $2}'`
    if cmp -s $1 $2 ; then
        echo The files are identical.  | l
    else
        xtermbar "sd $1 $2"
        diff -bdNsyw --width $cols $* 2>&1 | l
    fi
}

cvsd2() {
    width=`stty size | awk '{print $2}'`
    cvs diff -btyW $width $* | fmtsdiff $width | less '+/%[<>|]%'
}

sd2() {
    xtermbar "sd2 $1 $2"
    width=`stty size | awk '{print $2}'`
    diff -btyW $width $* | fmtsdiff $width | less '+/%[<>|]%'
}

xless() {
    typeset args file dir i olddir
    olddir=$PWD

    for i in $* ; do
        if [[ -f $i ]] ; then
            # figure out the directory, minus the last four path components.
            dir=${i%/*/*/*/*/*}
            # figure out the last four components.
            file=${i##$dir}
            # strip off an extra slash
            file=${file#/}
            # if the above algorithm messes up, $file will be null.
            # in that case just pass the args thru unmodified.
            # this can happen if the full path has less than four
            # components, or if the path doesn't start with '/'.
            if [[ x$file = x || x$dir = x ]] ; then
                dir=.
                file=$i
            fi
            # rebuild command line with the filename argument, so that
            # the filename arg appears just as we want it at the bottom
            # of the xterm.
            args="$args $file"
        else
            args="$args $i"
        fi
    done

    if [[ x$file = x ]] ; then
        echo "I didn't find any files on the command line."
        return
    fi

    if [[ x$dir != x ]] ; then
        cd $dir
    fi

    typeset OLDLESS
    OLDLESS="$LESS"
    LESS="$XLESS"
    export LESS

    xterm -title "+ ${file##*/}" -name XLESS +sb -g 80x45 -e less $args &

    LESS="$OLDLESS"
    cd $olddir
}

z() {
    typeset logfile tempfile count
    typeset CLASS INSTANCE RECIPIENTS OPCODE

    logfile=$HOME/.messages
    tempfile=$TMP/zwrite.$USER.$$

    CLASS=
    INSTANCE=
    RECIPIENTS=
    OPCODE=

    count=0

    while [[ $# -gt 0 ]] ; do
        case "$1" in
        -c)
            CLASS=$2
            shift
            ;;
        -i)
            INSTANCE=$2
            shift
            ;;
        -O)
            OPCODE=$2
            shift
            ;;
        -*)
            break
            ;;
        *)
            RECIPIENTS="$RECIPIENTS $1"
            count=$(( count + 1 ))
            ;;
        esac
        shift
    done

    test -t 0 && print Enter your message, followed by control-D.

    cat > $tempfile

    print -n 'Message '

    [[ "x$RECIPIENTS" = "x" ]] || {
        print -- ------------------------------------------------------------
        print -n MESSAGE SENT TO
        [[ "x$CLASS"      = "x" ]] || print -n " class"     $CLASS
        [[ "x$INSTANCE"   = "x" ]] || print -n " instance"  $INSTANCE
        [[ "x$OPCODE"     = "x" ]] || print -n " opcode"    $OPCODE
        if [[ $count = "1" ]] ; then 
            print -n " recipient" $RECIPIENTS
        else
            print -n " recipients" $RECIPIENTS
        fi
        print -n " -- " ; date
        cat $tempfile
    } >> $logfile

    [[ "x$CLASS"      = "x" ]] || CLASS="-c $CLASS"
    [[ "x$INSTANCE"   = "x" ]] || INSTANCE="-i $INSTANCE"
    [[ "x$OPCODE"     = "x" ]] || OPCODE="-O $OPCODE"

    [[ $count = "0" || $count = "1" ]] || {
        print ""
        print "@center(CC: $RECIPIENTS)"
    } >> $tempfile

    zwrite -n -q $OPCODE $CLASS $INSTANCE $RECIPIENTS < $tempfile

    test -t 0 && print sent.

    rm -f $tempfile
}

ediff() {
    if [ $# -ne 2 ] ; then
        echo usage : file-1 file-2
        return
    fi

    lisp=$HOME/ediff.$$

    cat << EOF > $lisp
        (custom-set-variables
          '(ediff-split-window-function 'split-window-horizontally)
          '(blink-matching-paren-distance nil)
          '(inhibit-startup-buffer-menu t)
          '(inhibit-startup-echo-area-message (getenv "USER"))
          '(inhibit-startup-screen t)
          '(menu-bar-mode nil)
          '(tool-bar-mode nil)
          )
        (ediff "$1" "$2")
EOF

    emacs -g 162x70+5+5 --no-init-file --load $lisp

    rm -f $lisp
}

merge3() {
    typeset lisp

    if [ $# -ne 4 ] ; then
        echo usage : file-A file-B common-ancestor output
        return
    fi

    lisp=$HOME/merge3.$$

    cat << EOF > $lisp
        (tool-bar-mode 0)
        (ediff-merge-files-with-ancestor "$1" "$2" "$3" nil "$4")
EOF

    emacs -g 162x54+5+5 --no-init-file --load $lisp

    rm -f $lisp
}

merge2() {
    typeset lisp

    if [ $# -ne 3 ] ; then
        echo usage : file-A file-B output
        return
    fi

    lisp=$HOME/merge3.$$

    cat << EOF > $lisp
        (tool-bar-mode 0)
        (ediff-merge-files "$1" "$2" nil "$3")
EOF

    emacs -g 162x54+5+5 --no-init-file --load $lisp

    rm -f $lisp
}

d1() {
    DISPLAY=${DISPLAY%%:*}:1.0 $* &
}
d2() {
    DISPLAY=${DISPLAY%%:*}:2.0 $* &
}
d3() {
    DISPLAY=${DISPLAY%%:*}:3.0 $* &
}

fp() {
    print $PWD/$1
}

title() {
    shellstring "$*"
    xtermbar $*
}

sendtree() {
    if [[ $# -lt 3 ]] ; then
        echo 'usage: sendtree host port dir [dir..]'
        return 1
    fi
    typeset host port
    host=$1
    port=$2
    shift 2
    tar cf - $* | i2 -v $host $port
}

gettree() {
    if [[ $# -ne 1 ]] ; then
        echo 'usage: gettree port'
        return 1
    fi
    i2 -v $1 | tar xf -
}

__aesenc() {
    if [ $# -ne 2 ] ; then
        echo usage : aesenc pass file
    else
        pass=$1
        infile=$2
        outfile=$2.enc
        openssl aes-256-cbc -e -salt -in $infile -out $outfile -pass pass:$pass
        ls -l $infile $outfile
    fi
}

aesenc() {
    pass=$1
    shift
    for f in $* ; do
        __aesenc $pass $f
    done
}

__aesdec() {
    if [ $# -ne 2 ] ; then
        echo usage : aesdec pass file
    else
        pass=$1
        infile=$2
        outfile=${2%.enc}
        openssl aes-256-cbc -d -in $infile -out $outfile -pass pass:$pass
        ls -l $infile $outfile
    fi
}

aesdec() {
    pass=$1
    shift
    for f in $* ; do
        __aesdec $pass $f
    done
}

if __isksh ; then
    __sed=''
    if [[ -f /bin/sed ]] ; then
        __sed=/bin/sed
    elif [[ -f /usr/bin/sed ]] ; then
        __sed=/usr/bin/sed
    fi
    if [[ x$__sed != x ]] ; then
        dir() {
            ls -l $* | $__sed 's, ->.*, @,'
        }
    fi
fi

__verbose funcs and aliases done

#  
# allow per-host customizations.  note that the file
# .kshrc.local must have execute permissions
#  

if __isksh ; then
    xconsole_hook() {
        return 0
    }
    if [[ -f $HOME/.kshrc.local ]] ; then
        __verbose sourcing kshrc.local
        . $HOME/.kshrc.local
        __verbose DONE sourcing kshrc.local
    else
        __verbose no kshrc.local
    fi
fi

#
# noninteractive shells don't do any more.
#

if __noninteractive ; then 
    __verbose noninteractive shell, exiting
    return
fi

# prevent bugs with recursive myshell scripts

unset __MYSHELL_LAUNCHER

#
# now try to ensure that we're running pfksh.
# if we can find a pfksh, copy it to $TMPDIR
# and then exec. otherwise continue running
# what we have.
#

ksh_new=@prefix@/$PFKARCH/bin/pfksh

if [ $0 = "/bin/ksh" ] ; then
    SHELL=/bin/ksh
fi

if __isksh ; then
    if [[ x$GOOD_SHELL = x ]] ; then
        if [[ -x $ksh_new ]] ; then
            ksh_final=$ksh_new
        elif [[ -x /bin/ksh ]] ; then
            ksh_final=/bin/ksh
        elif [[ -x /usr/local/bin/ksh ]] ; then
            ksh_final=/usr/local/bin/ksh
        else
            print 'WARNING: USING /bin/sh!'
            ksh_final=/bin/sh
        fi
        if [[ $SHELL != $ksh_final ]] ; then
            __verbose switching shells, $SHELL to $ksh_final
            GOOD_SHELL=yes
            export GOOD_SHELL
            SHELL=$ksh_final
            export SHELL
            exec $ksh_final
        fi
    fi
else
    if [ x$GOOD_SHELL = x ] ; then
        if [ -x $ksh_new ] ; then
            ksh_final=$ksh_new
        elif [ -x /bin/ksh ] ; then
            ksh_final=/bin/ksh
        elif [ -x /usr/local/bin/ksh ] ; then
            ksh_final=/usr/local/bin/ksh
        else
            echo 'WARNING: USING /bin/sh!'
            ksh_final=/bin/sh
        fi
        if [ $SHELL != $ksh_final ] ; then
            __verbose switching shells, $SHELL to $ksh_final
            GOOD_SHELL=yes
            export GOOD_SHELL
            SHELL=$ksh_final
            export SHELL
            exec $ksh_final
        fi
    fi
fi

unset GOOD_SHELL

__verbose running correct shell, finishing setup

#
# after switching shells we will reenter this script
# and wind up here, finishing the script.
#

unset ksh_new ksh_final

# set up keybindings that pfksh understands.

if __isksh ; then
   if [[ x$TERM != "dumb" ]] ; then
       # for some reason that i don't sufficiently understand,
       # emacs ssh tramp doesn't work if these happen. TERM=dumb
       # seems to be good enough to detect that condition.
       bind '^I'=complete-list
       bind '^V'=quote
       bind '^@'=set-mark-command
   fi
fi

__verbose bindings complete

if __isksh ; then
    if [[ x$XCONSOLE = xyes ]] ; then
        unset XCONSOLE
        I_AM_XCONSOLE=yes
        xsetroot -solid \#203040
        cd $HOME
        xrdb -load .Xresources
        fluxbox&
        xtermbar Console
        xconsole_hook
        SHELLFILESTRING=shell,$HOST,$REMOTE_HOST,$$,$TTY,console
    else
        if [[ x$WINDOW = x ]] ; then
            SHELLFILESTRING=shell,$HOST,$REMOTE_HOST,$$,$TTY
        else
            SHELLFILESTRING=shell,$HOST,$REMOTE_HOST,$$,$TTY,w$WINDOW,sty$STY
        fi
    fi
    SHELLFILE=$HOME/.y.shell.$HOST.$$
    trap "rm -f $SHELLFILE         "          EXIT
    trap "rm -f $SHELLFILE ; exit 0" HUP TERM EXIT
    cd() {
        if [[ $# -eq 0 ]] ; then
            command cd
        else
            command cd "$*"
        fi
        if [[ x$INSIDE_EMACS != x ]] ; then
            echo SHELL_CWD_BEGIN:$PWD:SHELL_CWD_END
        fi
        typeset file_part bardisp
        if [[ "x$SHELLFILESPECIAL" != x ]] ; then
            bardisp="$SHELLFILESPECIAL:"
        else
            bardisp=""
        fi 
        eval `make_file_part "$PWD" file_part`
        if [[ "x$CLEARCASE_ROOT" == x || "x$CLEARCASE_ROOT" == x/view/gsdStart ]] ; then
            bardisp="$bardisp$file_part"
        else
            typeset viewname
            viewname="${CLEARCASE_ROOT#/view/}"
            bardisp="$bardisp[$viewname]:$file_part"
        fi
        _set_prompt "$bardisp"
        if [[ "x$DISPLAY" != x ]] ; then
            bardisp="$USER@$HOST:$bardisp"
            if [[ x$I_AM_XCONSOLE == x ]] ; then
                if [[ x$INSIDE_EMACS == x ]] ; then
                    xtermbar "$bardisp"
                fi
            fi
        fi
        if [[ "x$TMUX" != x ]] ; then
            bardisp=`echo $PWD | awk '{i=length($1)-21; if (i<0) i=0; print substr($1,i); }'`
            xtermbar $bardisp
        fi
        CDPATH=.:$ti/src:$cpe/src:$HOME
        echo $SHELLFILESTRING,$DISPLAY,$viewname,$PWD,$SHELLFILESPECIAL > $SHELLFILE
    }
    shellstring() {
        SHELLFILESPECIAL=$1
        cd .
    }
    shells() {
        cat $HOME/.y.*
    }

    # update xterm title
    cd .
fi

umask 022

#
# these must be after the environment variables, 
# because setting HISTSIZE resets the emacs option.
# i don't know why that should be so.
#

__verbose starting settings

set -o nolog
set -o emacs
set -o trackall
set +o bgnice

__verbose settings complete
__verbose done with kshrc, enjoy your shell

# Local Variables:
# mode: Shell-script
# indent-tabs-mode: nil
# tab-width: 8
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "Last update: "
# time-stamp-format: "%:y-%02m-%02d.%02H:%02M:%02S"
# time-stamp-end: "$"
# End:
