#!/bin/bash

# TODO : implement 'remove'

# dir structure:
#    <base>/_repos/<repo>
#    <base>/_repos/<repo>/worktrees/<work1>/
#    <base>/_repos/<repo>/worktrees/<work2>/
#    <base>/<work1>/ etc
#    <base>/<work2>/ etc

reposdir=.pfkwtgit

# arg : repo_dir
parse_submodules() {
    cd "$1"
    export SUBMOD_FILE=$( mktemp )

    if [[ ! -f .gitmodules ]] ; then
        numsubmods=0
        return
    fi

    export ORIGIN_URL=$( git config --get remote.origin.url )

    awk '
BEGIN {
   numsubmods=0;
   submod="";
   path="";
   url="";
}

/^\[submodule / {
  save_previous();
  submod = gensub(/^.*"(.*)".*$/, "\\1", "g", $0);
}

/path.*=/ {
  path = equalvalue($0)
}

/url.*=/ {
  url = equalvalue($0)
  nurl = split(url,urlcomponents,/\//)
  if (nurl > 1 && urlcomponents[1] == "..")
  {
    # parsing relative urls is a LOT easier in awk than it
    # is in bash script.....
    origin_url = ENVIRON["ORIGIN_URL"]
    print "RELATIVE URL = " url
    print "NOTE origin = " origin_url
    norig = split(origin_url,origincomponents,/\//)
    relstart=1
    while (urlcomponents[relstart] == "..")
    {
      relstart++
      norig--
    }
    finalurl="";
    for (ind=1;ind<=norig;ind++)
    {
      if (ind!=1)
      {
#       print "ADDING /"
        finalurl = finalurl "/"
      }
#     print "ADDING " origincomponents[ind]
      finalurl = finalurl origincomponents[ind]
    }
    for (ind=relstart;ind<=nurl;ind++)
    {
#     print "ADDING /"
      finalurl = finalurl "/"
#     print "ADDING " urlcomponents[ind]
      finalurl = finalurl urlcomponents[ind]
    }
    print "URL = " finalurl
    url=finalurl
  }
}

END {
  save_previous();
  cmd = "git submodule status"
  while ((cmd | getline) > 0) {
    commit = gensub(/^.([0-9a-f]*) ([^\(\)]*)( \((.*)\))?$/, "\\1", "g", $0)
    path   = gensub(/^.([0-9a-f]*) ([^\(\)]*)( \((.*)\))?$/, "\\2", "g", $0)
    desc   = gensub(/^.([0-9a-f]*) ([^\(\)]*)( \((.*)\))?$/, "\\4", "g", $0)
    for (ind=0;ind < numsubmods; ind++) {
      if (path == submods[ind][1]) {
        submod = submods[ind][0]
        url    = submods[ind][2]
        print "submods[" ind "]=\"" submod "\"" >> ENVIRON["SUBMOD_FILE"]
        print "paths[" ind "]=\"" path "\""     >> ENVIRON["SUBMOD_FILE"]
        print "urls[" ind "]=\"" url "\""       >> ENVIRON["SUBMOD_FILE"]
        print "commits[" ind "]=\"" commit "\"" >> ENVIRON["SUBMOD_FILE"]
      }
    }
  }
  close(cmd)
  print "numsubmods=" numsubmods >> ENVIRON["SUBMOD_FILE"]
}

function equalvalue(zero) {
   return gensub(/^.*= *(.*)$/, "\\1", "g", zero);
}

function save_previous() {
  if (submod != "") {
      submods[numsubmods][0]=submod
      submods[numsubmods][1]=path
      submods[numsubmods][2]=url
      numsubmods++;
  }
  submod="";
  path="";
  url="";
}
' .gitmodules

    . $SUBMOD_FILE
#   cat $SUBMOD_FILE
    rm -f $SUBMOD_FILE
    unset SUBMOD_FILE
}

# args <base> <url>
wtclone() {
    base="$1"
    local url="$2"
    local reponame=$( basename "${url%/}" )
    reponame="${reponame%.git}"

    if [[ ! -d "${base}/${reposdir}/${reponame}" ]] ; then
        echo $reponame does not exist, cloning...
        mkdir -p "${base}/${reposdir}"
        cd "${base}/${reposdir}"
        git clone -n "$url" TEMPDIRNEWCLONE
        mv TEMPDIRNEWCLONE/.git "${reponame}"
        rm -rf TEMPDIRNEWCLONE
        if [[ ! -f SUPER ]] ; then
            echo $reponame > SUPER
        fi
        cd "${reponame}"
        git rev-parse HEAD > NEWHEAD
        mv NEWHEAD HEAD
    else
        echo $reponame already exists
#        cd "${base}/${reposdir}/${reponame}"
#        git fetch --tags
    fi
}

# args <base> <reponame> <modulename> <moduledir> <commit>
#  <reponame> is the repo; <base>/${reposdir}/<reponame> must exist.
#  <moduledir> is where it should be populated; it must be empty or not exist
#  <commit> is the commit-ish that should be populated.
wt_add() {

    local relbase="$1"
    mkdir -p "${relbase}"
    cd "${relbase}"
    local base="$PWD"
    echo relbase = $relbase
    echo 1 base = $base
    local reponame="${2%.git}"
    echo 2 reponame=$reponame

    local modulename="$3"
    echo 3 modulename=$modulename

    local moduledir="$4"
    echo 4 moduledir=$moduledir
    if [[ "x${moduledir#/}" == "x${moduledir}" ]] ; then
        moduledir=${base}/${moduledir}
    fi
    echo 4 abs moduledir=$moduledir

    local commit="$5"
    echo 5 commit=$commit

    local supername=$( cat "${base}/${reposdir}/SUPER" )
    echo supername=$supername

    cd "${base}/${reposdir}/${reponame}"
    local commitsha=$( git rev-parse "$commit" 2> /dev/null )
    if [[ "x$commitsha" == x ]] ; then
        echo ERROR: cannot rev-parse commit-ish $commit
        exit 1
    fi
    cd "${base}"

    wtbase="${base}/${reposdir}/${reponame}/worktrees"
    noslashmodname=$( echo ${modulename} | tr / - )
    modwtdir="${wtbase}/${noslashmodname}"

    echo commitsha=$commitsha
    echo wtbase=$wtbase
    echo noslashmodname=$noslashmodname
    echo modwtdir=$modwtdir

    mkdir -p "${modwtdir}"
    cd       "${modwtdir}"

    # error messages like
    # fatal: 'master' is already checked out at 'path'
    # contain a <slightly> more useful path
    echo "${moduledir}/${path}" > gitdir
    echo "${base}/${reposdir}/${reponame}" > commondir
    echo $commitsha > HEAD

    mkdir -p "${moduledir}"
    cd "${moduledir}"
    echo "gitdir: ${modwtdir}" > .git
    git reset --hard
    git submodule init
    parse_submodules

    local ind=0
    while [[ $ind -lt $numsubmods ]] ; do

        local submod="${submods[$ind]}"
        local path="${paths[$ind]}"
        local url="${urls[$ind]}"
        local commit="${commits[$ind]}"

        echo processing submod $ind '(' $path ')'

        local reponame=$( basename ${url%/} )
        reponame="${reponame%.git}"

        # we have to reinvoke ourselves as new BASH instances because
        # parse_submodules sets global vars, so the recursive nature
        # of submodules in submodules breaks.  in other words, this
        # function is not re-entrant.  we should find a way to 'eval'
        # parse_submodules values into function-locals so we can
        # recurse safely.

        $0 clone "$base" "$url"
        $0 _add "$base" "$reponame" "$modulename/modules/$submod" "${moduledir}/${path}" "$commit"

        (( ind++ ))
    done

}

# args <base> <workdir> <commit>
wtadd() {
    base="$1"
    local workdir="$2"
    local commit="$3"
    echo base=$base
    echo workdir=$workdir
    echo commit=$commit

    if [[ ! -f "${base}/${reposdir}/SUPER" ]] ; then
        echo 'ERROR: not a base dir? no ${reposdir}/SUPER file....'
        exit 1
    fi

    reponame=$( cat "${base}/${reposdir}/SUPER" )

    wt_add "$base" "$reponame" "$workdir" "$workdir" "$commit"
}

wtstatus() {
    base="$1"
    cd $base
    gitfiles=$( find . -name .git -type f )
    max=0
    for gf in $gitfiles ; do
        d=${gf%/.git}
        d=${d#./}
        l=${#d}
        if [[ $l -gt $max ]] ; then
            max=$l
        fi
    done
    for gf in $gitfiles ; do
        d=${gf%/.git}
        d=${d#./}
        set -- $( cat $gf )
        gd="$2"
        head=$( cat $gd/HEAD )
        printf "%-${max}s  %s\n" "$d" "$head"
    done
}

if [[ "x$1" == "xclone" ]] ; then

    wtclone "$2" "$3"

elif [[ "x$1" == "x_add" ]] ; then

    wt_add "$2" "$3" "$4" "$5" "$6"

elif [[ "x$1" == "xadd" ]] ; then

    if [[ "x$4" == "x" ]] ; then
        commit=HEAD
    else
        commit="$4"
    fi
    wtadd "$2" "$3" "$commit"

elif [[ "x$1" == "xstatus" ]] ; then

    wtstatus "$2"

else

    echo 'usage : git pfkwt  clone BASEDIR URL'
    echo '        git pfkwt    add BASEDIR WORKDIR COMMIT'
    echo '        git pfkwt status BASEDIR'
    exit 1

fi

exit 0
