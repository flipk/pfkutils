
%{

#include <stdio.h>
#include "tokenizer.h"
#include "parser.h"

extern int yylex( void );
extern void yyerror( char * e );

extern int yylineno; // autogenerated by flex

static struct makefile parser_makefile;

#define YYDEBUG 1

%}

%union
{
    int value;
    char * word;
    struct wordlist * wordlist;
    struct variable * variable;
    struct command * command;
    struct rule * rule;
}

%token COLON PLUSEQ EQ NL TAB BSNL EMPTY

%token <word> WORD

%type <wordlist> WORDLIST
%type <command> COMMANDS
%type <command> COMMAND
%type <rule> RULE
%type <variable> VARIABLE

%start MAKEFILE

%%

MAKEFILE
	: LINE
	| LINE MAKEFILE
	;

LINE
	: NL
	| VARIABLE
        {
            if (parser_makefile.variables_tail)
            {
                parser_makefile.variables_tail->next = $1;
                parser_makefile.variables_tail = $1;
            }
            else
            {
                parser_makefile.variables      = $1;
                parser_makefile.variables_tail = $1;
            }
        }
	| RULE
        {
            if (parser_makefile.rules_tail)
            {
                parser_makefile.rules_tail->next = $1;
                parser_makefile.rules_tail = $1;
            }
            else
            {
                parser_makefile.rules = $1;
                parser_makefile.rules_tail = $1;
            }
        }
	;

VARIABLE
	: WORD EQ WORDLIST NL
	{
            $$ = makevariable($1,$3);
        }
	| WORD EQ NL
	{
            $$ = makevariable($1,NULL);
        }
	| WORD PLUSEQ WORDLIST NL
	{
            $$ = makevariable($1,$3);
            $$->sum = 1;
        }
	| WORD PLUSEQ NL
	{
            $$ = makevariable($1,NULL);
            $$->sum = 1;
        }
	;

WORDLIST
	: WORD
	{
            $$ = makewordlist($1);
        }
	| WORD WORDLIST
	{
            $$ = makewordlist($1);
            $$->next = $2;
        }
	| BSNL WORDLIST
        {
            $$ = $2;
        }
	;

RULE
	: WORDLIST COLON WORDLIST NL COMMANDS
	{
            $$ = makerule($1, $3, $5 );
        }
	| WORDLIST COLON WORDLIST NL NL
        {
            $$ = makerule($1, $3, NULL);
        }
	| WORDLIST COLON NL COMMANDS
	{
            $$ = makerule($1, NULL, $4);
        }
	| WORDLIST COLON NL
	{
            $$ = makerule($1, NULL, NULL);
        }
	;

COMMANDS
	: COMMAND
        {
            $$ = $1;
        }
	| COMMAND COMMANDS
        {
            $$ = $1;
            $$->next = $2;
        }
	;

COMMAND
	: TAB WORDLIST NL
        {
            $$ = makecommand($2);
        }
        ;

%%

void
yyerror( char * e )
{
    fprintf(stderr, "error: %d: %s\n", yylineno, e);
    exit( 1 );
}

void
parser_init(void)
{
    memset(&parser_makefile, 0, sizeof(parser_makefile));
}

struct wordlist *
makewordlist(char *word)
{
    struct wordlist * ret;

    ret = (struct wordlist *) malloc(sizeof(struct wordlist));
    ret->next = NULL;
    ret->word = word;
    return ret;
}

void
printwordlist(struct wordlist *wordlist)
{
    while (wordlist)
    {
        printf("%s", wordlist->word);
        wordlist = wordlist->next;
        if (wordlist)
            printf(" ");
    }
}

struct variable *
makevariable(char *word, struct wordlist *value)
{
    struct variable * ret;
    ret = (struct variable *) malloc( sizeof(struct variable));
    ret->next = NULL;
    ret->variable = word;
    ret->value = value;
    ret->sum = 0;
    return ret;
}

void
printvariable(struct variable *var)
{
    while (var)
    {
        printf("%s ", var->variable);
        if (var->sum)
            printf("+= ");
        else
            printf("= ");
        if (var->value)
            printwordlist(var->value);
        else
            printf("<empty>");
        printf("\n");
        var = var->next;
    }
}

struct command *
makecommand(struct wordlist *words)
{
    struct command * cmd;
    cmd = (struct command *) malloc(sizeof(struct command));
    cmd->next = NULL;
    cmd->command = words;
    return cmd;
}

void
printcommand(struct command *command)
{
    while (command)
    {
        printf("\t");
        printwordlist(command->command);
        command = command->next;
        printf("\n");
    }
}

struct rule *
makerule(struct wordlist *targets,
         struct wordlist *sources,
         struct command *commands)
{
    struct rule * ret;
    ret = (struct rule *) malloc( sizeof(struct rule));
    ret->next = NULL;
    ret->targets = targets;
    ret->sources = sources;
    ret->commands = commands;
    return ret;
}

void
printrule(struct rule *rule)
{
    while (rule)
    {
        if (rule->targets)
            printwordlist(rule->targets);
        printf(": ");
        if (rule->sources)
            printwordlist(rule->sources);
        printf("\n");
        if (rule->commands)
        {
            printcommand(rule->commands);
        }
        rule = rule->next;
    }
}

void
printmakefile(struct makefile *makefile)
{
    printvariable(makefile->variables);
    printrule(makefile->rules);
}

struct makefile *
parse_makefile(char *fname)
{
    struct makefile * ret;
    ret = (struct makefile *) malloc( sizeof(struct makefile));
    FILE * in = fopen(fname, "r");
    if (!in)
        return NULL;
    tokenizer_init(in);
    parser_init();
    yyparse();
    memcpy(ret, &parser_makefile, sizeof(parser_makefile));
    return ret;
}

void
print_tokenized_file(char *fname)
{
    FILE * in = fopen(fname, "r");
    if (!in)
        return;
    tokenizer_init(in);
    while (1)
    {
        int c = yylex();
        printf("got %d (%s)", c, c <= YYMAXTOKEN ? yyname[c] : "");
        if (c == WORD) printf(" (%s)", yylval.word);
        printf("\n");
        if (c <= 0)
            break;
    }
}
