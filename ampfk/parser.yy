
%{

#include <stdlib.h>
#include <string>
#include <iostream>
#include "tokenizer.h"
#include "automake_parser.h"

extern int yylex( void );
extern void yyerror( const std::string e );
extern int yylineno; // autogenerated by flex

#define YYDEBUG 1

using namespace std;

automake_file * parser_amf;

%}

%union
{
    std::string * word;
    amwordList * wordlist;
    amvariable * var;
    amrule * rule;
    amcommand * command;
    amcommandList * commands;
}

%token COLON PLUSEQ EQ NL TAB BSNL EMPTY
%token    <word> WORD

%type <wordlist> WORDLIST
%type      <var> VARIABLE
%type     <rule> RULE
%type <commands> COMMANDS
%type  <command> COMMAND

%start MAKEFILE

%%

MAKEFILE
	: LINE
	| LINE MAKEFILE
	;

LINE
	: NL
	| VARIABLE
        {
            if ($1)
            {
                if ($1->sum)
                {
                    amvariable * v = parser_amf->input_variables.find(*$1->var);
                    if (v)
                    {
                        v->appendfrom($1);
                        delete $1;
                    }
                    else
                    {
                        cerr << "line " << (yylineno-1) << " appends variable "
                             << *$1->var << " but variable not set!" << endl;
                        exit(1);
                    }
                }
                else
                    parser_amf->input_variables.add($1);
            }
        }
	| RULE
        {
            parser_amf->input_rules.add($1);
        }
	;

VARIABLE
	: WORD EQ WORDLIST NL
        {
            int len = $1->size();
            $$ = new amvariable;
            $$->appendfrom($3);
            delete $3;
            // note the parser can actually tokenize
            // the string VAR+=value into
            // WORD("VAR+") EQ WORD("value")
            // which is kinda silly.
            if ((*$1)[len-1] == '+')
            {
                $1->erase(len-1,1);
                $$->sum = true;
            }
            $$->var = $1;
        }
	| WORD EQ NL
        {
            $$ = new amvariable;
            $$->var = $1;
        }
	| WORD PLUSEQ WORDLIST NL
        {
            $$ = new amvariable;
            $$->var = $1;
            $$->sum = true;
        }
	| WORD PLUSEQ NL
        {
            // just don't need it.
            delete $1;
            $$ = NULL;
        }
	;

WORDLIST
	: WORD
        {
            amword * w = new amword;
            w->word = $1;
            $$ = new amwordList;
            $$->add(w);
        }
	| WORD WORDLIST
        {
            amword * w = new amword;
            w->word = $1;
            // odd that dll2 doesn't have an 'add_head' method
            if ($2->get_cnt() == 0)
                $2->add(w);
            else
                $2->add_before(w, $2->get_head());
            $$ = $2;
        }
	| BSNL WORDLIST
        {
            $$ = $2;
        }
	;

RULE
	: WORDLIST COLON WORDLIST NL COMMANDS
        {
            $$ = new amrule;
            $$->appendtargetsfrom($1);
            $$->appendsourcesfrom($3);
            $$->appendcommandsfrom($5);
            delete $1;
            delete $3;
            delete $5;
        }
	| WORDLIST COLON WORDLIST NL NL
        {
            $$ = new amrule;
        }
	| WORDLIST COLON NL COMMANDS
        {
            $$ = new amrule;
            $$->appendtargetsfrom($1);
            $$->appendcommandsfrom($4);
            delete $1;
            delete $4;
        }
	| WORDLIST COLON NL
        {
            $$ = new amrule;
        }
	;

COMMANDS
	: COMMAND
        {
            $$ = new amcommandList;
            $$->add($1);
        }
	| COMMAND COMMANDS
        {
            if ($2->get_cnt() == 0)
                $2->add($1);
            else
                $2->add_before($1, $2->get_head());
            $$ = $2;
        }
	;

COMMAND
	: TAB WORDLIST NL
        {
            $$ = new amcommand;
            $$->appendfrom($2);
            delete $2;
        }
        ;

%%

void
yyerror( const std::string e )
{
    fprintf(stderr, "error: %d: %s\n", yylineno, e.c_str());
    exit( 1 );
}



void
print_tokenized_file(void)
{
    while (1)
    {
        int c = yylex();

        cout << "got " << c << " ("
             <<  (c <= YYNTOKENS ? yytname[c-255] : 0)
             << ")";
        if (c == WORD)
            cout << " (" << *yylval.word << ")";
        cout << endl;
        if (c <= 0)
            break;
    }
}
