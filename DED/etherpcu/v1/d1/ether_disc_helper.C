
// note that this file is included from the autogenerated ether_disc.C

#define DEBUG 0

int
ETHER_DISC_STATE_MACHINE :: input_discriminator( void * _m )
{
    ETHER_DISC_INPUT_MSG * m = (ETHER_DISC_INPUT_MSG *)_m;
    bool same;

    switch ( m->type )
    {
    case ETHER_DISC_INPUT_MSG::C1_ASSERTION:
        return ASSERTED_C1;

    case ETHER_DISC_INPUT_MSG::TIMER_INDICATION:
        if ( m->sequence_number != timer_sequence )
            return UNKNOWN_INPUT;
        return TIMEOUT_INPUT;

    case ETHER_DISC_INPUT_MSG::BECOME_SECONDARY:
        return BECOME_SECONDARY;

    case ETHER_DISC_INPUT_MSG::IML_INDICATION:
        same = (mac_received == m->ether_src_mac);
        mac_received = m->ether_src_mac;

        switch ( m->ether_type )
        {
        case E_START_BCAST:    return same ?
                                   START_C1_SAME_MAC  : START_C1_DIFF_MAC;
        case E_FINISH_BCAST:   return same ?
                                   FINISH_C1_SAME_MAC : FINISH_C1_DIFF_MAC;
        case E_CLAIM:          return I_CLAIM;
        case E_CLAIM_ACK:      return I_CLAIM_ACK;
        case E_CLAIM_NMM:      return I_CLAIM_NMM;
        case E_HEARTBEAT:      return I_HEARTBEAT;
        case E_HEARTBEAT_ACK:  return I_HEARTBEAT_ACK;
        }
        break;
    }
	return UNKNOWN_INPUT;
}

void
ETHER_DISC_STATE_MACHINE :: output_generator( int ty )
{
    switch ( ty )
    {
    case O_CLAIM:
        ether->tx( mproc->mac, mac_other_mproc, E_CLAIM );
        break;
    case O_CLAIM_ACK:
        ether->tx( mproc->mac, mac_other_mproc, E_CLAIM_ACK );
        break;
    case O_CLAIM_NMM:
        if ( mac_other_mproc != -1 )
        {
            ether->tx( mproc->mac, mac_other_mproc, E_CLAIM_NMM );
            mac_other_mproc = -1;
        }
        if ( mac_received != -1 )
        {
            ether->tx( mproc->mac, mac_received, E_CLAIM_NMM );
            mac_received = -1;
        }
        break;
    case O_HEARTBEAT:
        ether->tx( mproc->mac, mac_other_mproc, E_HEARTBEAT );
        break;
    case O_HEARTBEAT_ACK:
        ether->tx( mproc->mac, mac_other_mproc, E_HEARTBEAT_ACK );
        break;
    case RESTART_AUDIT:
        mproc->restart_audit();
        break;
    case ADD_LINK:
        mproc->haslink = true;
        if ( mac_other_mproc == mproc->other->mac )
        {
            mproc->printf( "link established (%d,%d,%d)\n",
                           mac_other_mproc, mproc->mac, mproc->other->mac );
            mproc->whattodo = MPROC_Thread::DIE;
        }
        else
            mproc->printf( "link established to WRONG MPROC! (%d,%d,%d)\n",
                           mac_other_mproc, mproc->mac, mproc->other->mac );
        break;
    case REMOVE_LINK:
        if ( mproc->haslink == true )
        {
            mproc->printf( "link destroyed!\n" );
            mproc->haslink = false;
        }
        break;
    case PRIMARY_FAILED:
        //xxx
        mproc->printf( "my primary has failed an audit!\n" );
        break;
    }
}

void
ETHER_DISC_STATE_MACHINE :: unknown_message( void * m )
{
}

void
ETHER_DISC_STATE_MACHINE :: unhandled_message( int type )
{
}

void
ETHER_DISC_STATE_MACHINE :: debug_transition_hook( 
	int input, int old_state, int new_state )
{
#if DEBUG
    ThreadShortCuts::printf( "input %s: %s -> %s\n",
                             dbg_input_name( input ),
                             dbg_state_name( old_state ),
                             dbg_state_name( new_state ));
#endif
}

void
ETHER_DISC_STATE_MACHINE :: set_timer( int val )
{
    int ticks = val / (1000 / mproc->tps());
    if ( ticks == 0 )
        ticks++;
    timer_id = mproc->set_ether_timer( ticks, timer_sequence );
    timer_set = true;
}

void
ETHER_DISC_STATE_MACHINE :: cancel_timer( void )
{
    if ( timer_set )
    {
        mproc->cancel( timer_id );
        timer_set = false;
        timer_sequence++;
    }
}

void
ETHER_DISC_STATE_MACHINE :: _first_call( void )
{
    current_state = ST1_WAITFOR_S;
}

enum ETHER_DISC_STATE_MACHINE::call_st6_same_mac_retvals
ETHER_DISC_STATE_MACHINE :: call_st6_same_mac( void )
{
    bool same = (mac_received == mac_other_mproc);

    mac_other_mproc = mac_received;

    if ( same )
        return SECOND_TRY;

    return FIRST_TRY;
}

enum ETHER_DISC_STATE_MACHINE::call_st8_last_hb_ack_ok_retvals
ETHER_DISC_STATE_MACHINE :: call_st8_last_hb_ack_ok( void )
{
    //xxx
    return ACK_OK;
}
