
// note that this file is included from the autogenerated ether_disc.C

#define DEBUG 0

int
ETHER_DISC_STATE_MACHINE :: input_discriminator( void * _m )
{
    ETHER_DISC_INPUT_MSG * m = (ETHER_DISC_INPUT_MSG *)_m;
    bool same;

    switch ( m->type )
    {
    case ETHER_DISC_INPUT_MSG::C1_ASSERTION:
        return ASSERTED_C1;

    case ETHER_DISC_INPUT_MSG::TIMER_INDICATION:
        if ( m->sequence_number != timer_sequence )
            return UNKNOWN_INPUT;
        return TIMEOUT_INPUT;

    case ETHER_DISC_INPUT_MSG::BECOME_SECONDARY:
        return BECOME_SECONDARY;

    case ETHER_DISC_INPUT_MSG::IML_INDICATION:
        same = (mac_received == m->ether_src_mac);
        mac_received = m->ether_src_mac;

        switch ( m->ether_type )
        {
        case E_CLAIM:          return I_CLAIM;
        case E_CLAIM_ACK:      return I_CLAIM_ACK;
        case E_CLAIM_NMM:      return I_CLAIM_NMM;
        case E_HEARTBEAT:      return I_HEARTBEAT;
        case E_HEARTBEAT_ACK:  return I_HEARTBEAT_ACK;
        case E_START_BCAST:
        case E_FINISH_BCAST:
            break;
        default:               return UNKNOWN_INPUT;
        }

        // else its a start/finish broadcast;
        // manage mac list.
        ether_list_item * eli;

        if ( m->ether_type == E_START_BCAST )
        {
            // add mac to mac list if not there already
            bool found = false;

            call_purge_mac_list();
            for ( eli = active_macs.get_head(); eli;
                  eli = active_macs.get_next( eli ))
            {
                if ( eli->mac == mac_received )
                {
                    eli->timestamp = tickGet();
                    found = true;
                    break;
                }
            }

            if ( found == false )
            {
                eli = new ether_list_item;
                eli->mac = mac_received;
                eli->timestamp = tickGet();
                active_macs.add( eli );
            }
        }
        else if ( m->ether_type == E_FINISH_BCAST )
        {
            for ( eli = active_macs.get_head(); eli;
                  eli = active_macs.get_next( eli ))
            {
                if ( eli->mac == mac_received )
                {
                    active_macs.remove( eli );
                    // at this time, if the active list is now empty,
                    // then this mac we just removed was the valid mac
                    // we were looking for.  return the correct input
                    // to the state machine to indicate so.
                    if ( active_macs.get_cnt() == 0 )
                        return FINISH_BCAST;
                    // else break from for-loop.
                    break;
                }
            }
        }
        break;
    }

    return UNKNOWN_INPUT;
}

void
ETHER_DISC_STATE_MACHINE :: output_generator( int ty )
{
    switch ( ty )
    {
    case O_CLAIM:
        ether->tx( mproc->mac, mac_other_mproc, E_CLAIM );
        break;
    case O_CLAIM_ACK:
        ether->tx( mproc->mac, mac_other_mproc, E_CLAIM_ACK );
        break;
    case O_CLAIM_NMM:
        if ( mac_other_mproc != -1 )
        {
            ether->tx( mproc->mac, mac_other_mproc, E_CLAIM_NMM );
            mac_other_mproc = -1;
        }
        if ( mac_received != -1 )
        {
            ether->tx( mproc->mac, mac_received, E_CLAIM_NMM );
            mac_received = -1;
        }
        break;
    case O_HEARTBEAT:
        ether->tx( mproc->mac, mac_other_mproc, E_HEARTBEAT );
        break;
    case O_HEARTBEAT_ACK:
        ether->tx( mproc->mac, mac_other_mproc, E_HEARTBEAT_ACK );
        break;
    case RESTART_AUDIT:
        mproc->restart_audit();
        break;
    case ADD_LINK:
        has_link = true;
        mproc->haslink = true;
        if ( mac_other_mproc == mproc->other->mac )
        {
            mproc->printf( "link established (%d,%d,%d)\n",
                           mac_other_mproc, mproc->mac, mproc->other->mac );
            mproc->whattodo = MPROC_Thread::DIE;
        }
        else
            mproc->printf( "link established to WRONG MPROC! (%d,%d,%d)\n",
                           mac_other_mproc, mproc->mac, mproc->other->mac );
        break;
    case REMOVE_LINK:
        if ( has_link == true )
        {
            if ( mproc->haslink == true )
            {
                mproc->printf( "link destroyed!\n" );
                has_link = false;
                mproc->haslink = false;
            }
        }
        break;
    case PRIMARY_FAILED:
        // error!
        mproc->printf( "my primary has failed an audit!\n" );
        break;
    }
}

void
ETHER_DISC_STATE_MACHINE :: unknown_message( void * m )
{
}

void
ETHER_DISC_STATE_MACHINE :: unhandled_message( int type )
{
}

void
ETHER_DISC_STATE_MACHINE :: debug_transition_hook( 
    int input, int old_state, int new_state )
{
#if DEBUG
    ThreadShortCuts::printf( "input %s: %s -> %s\n",
                             dbg_input_name( input ),
                             dbg_state_name( old_state ),
                             dbg_state_name( new_state ));
#endif
}

void
ETHER_DISC_STATE_MACHINE :: set_timer( int val )
{
    int ticks = val / (1000 / mproc->tps());
    if ( ticks == 0 )
        ticks++;
    timer_id = mproc->set_ether_timer( ticks, timer_sequence );
    timer_set = true;
}

void
ETHER_DISC_STATE_MACHINE :: cancel_timer( void )
{
    if ( timer_set )
    {
        mproc->cancel( timer_id );
        timer_set = false;
        timer_sequence++;
    }
}

void
ETHER_DISC_STATE_MACHINE :: _first_call( void )
{
    ether_list_item * i;

    current_state = ST1_WAITFOR_C1;
    while ( 1 )
    {
        i = active_macs.get_head();
        if ( i == NULL )
            break;
        active_macs.remove( i );
        delete i;
    }
}

void
ETHER_DISC_STATE_MACHINE :: call_purge_mac_list( void )
{
    ether_list_item * eli, * neli;
    ULONG now = tickGet();
    for ( eli = active_macs.get_head(); eli; eli = neli )
    {
        ULONG diff = now - eli->timestamp;
        neli = active_macs.get_next( eli );
        if ( diff > MAC_MAX_AGE_VALUE )
        {
            ThreadShortCuts::printf( "mac %d timed off my active list\n",
                                     eli->mac );
            active_macs.remove( eli );
        }
    }
}

enum ETHER_DISC_STATE_MACHINE::call_mac_list_count_retvals
ETHER_DISC_STATE_MACHINE :: call_mac_list_count( void )
{
    int count = active_macs.get_cnt();
    if ( count == 0 )
        return ZERO_MACS;
    else if ( count == 1 )
        return ONE_MAC;
    return TWO_OR_MORE_MACS;
}

enum ETHER_DISC_STATE_MACHINE::call_st6_same_mac_retvals
ETHER_DISC_STATE_MACHINE :: call_st6_same_mac( void )
{
    bool same = (mac_received == mac_other_mproc);

    mac_other_mproc = mac_received;

    if ( same )
        return SECOND_TRY;

    return FIRST_TRY;
}

enum ETHER_DISC_STATE_MACHINE::call_st8_last_hb_ack_ok_retvals
ETHER_DISC_STATE_MACHINE :: call_st8_last_hb_ack_ok( void )
{
    // not used
    return ACK_OK;
}
