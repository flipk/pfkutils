
%{

#include <stdio.h>
#include "tokenizer.h"
#include "parser.h"

extern int yylex( void );
extern void yyerror( char * e );

extern int yylineno; // autogenerated by flex

static struct makefile * parser_makefile;

#define YYDEBUG 1

%}

%union
{
    int value;
    char * word;
    struct word * wordlist;
    struct variable * variable;
    struct command * command;
    struct rule * rule;
}

%token COLON PLUSEQ EQ NL TAB BSNL EMPTY

%token <word> WORD

%type <wordlist> WORDLIST
%type <command>  COMMANDS
%type <command>  COMMAND
%type <rule>     RULE
%type <variable> VARIABLE

%start MAKEFILE

%%

MAKEFILE
	: LINE
	| LINE MAKEFILE
	;

LINE
	: NL
	| VARIABLE
        {
            if ($1)
            {
                if ($1->sum)
                {
                    // locate original value and extend its value
                    struct variable * o;
                    for (o = parser_makefile->variables; o; o = o->next)
                    {
                        if (strcmp(o->variable, $1->variable) == 0)
                        {
                            if (0)
                            {
                                printf("adding value '");
                                printword($1->value);
                                printf("' to variable '%s'\n", o->variable);
                            }
                            addvarword(o, $1->value);
                            break;
                        }
                    }
                    if (o == NULL)
                    {
                        printf("line %d did var += value but "
                               "var '%s' not set\n",
                               yylineno, $1->variable);
                        exit(1);
                    }
                    // don't need that anymore
                    free($1->variable);
                    free($1);
                }
                else
                {
                    *parser_makefile->variables_next = $1;
                    parser_makefile->variables_next = &$1->next;
                }
            }
        }
	| RULE
        {
            *parser_makefile->rules_next = $1;
            parser_makefile->rules_next = &$1->next;
        }
	;

VARIABLE
	: WORD EQ WORDLIST NL
	{
            $$ = makevariable($1,$3);
            int wordlen = strlen($1);
            if ($1[wordlen-1] == '+')
            {
                // sigh. 
                // a statement like "VAR+=value" can actually
                // parse as "VAR+" EQ "value", which we have to fix.
                $$->sum = 1;
                $1[wordlen-1] = 0; // nuke the '+' from the varname
            }
        }
	| WORD EQ NL
	{
            $$ = makevariable($1,NULL);
        }
	| WORD PLUSEQ WORDLIST NL
	{
            $$ = makevariable($1,$3);
            $$->sum = 1;
        }
	| WORD PLUSEQ NL
	{
            // nothing to do, not adding anything.
            $$ = NULL;
        }
	;

WORDLIST
	: WORD
	{
            $$ = makeword($1);
        }
	| WORD WORDLIST
	{
            $$ = makeword($1);
            $$->next = $2;
        }
	| BSNL WORDLIST
        {
            $$ = $2;
        }
	;

RULE
	: WORDLIST COLON WORDLIST NL COMMANDS
	{
            $$ = makerule($1, $3, $5 );
        }
	| WORDLIST COLON WORDLIST NL NL
        {
            $$ = makerule($1, $3, NULL);
        }
	| WORDLIST COLON NL COMMANDS
	{
            $$ = makerule($1, NULL, $4);
        }
	| WORDLIST COLON NL
	{
            $$ = makerule($1, NULL, NULL);
        }
	;

COMMANDS
	: COMMAND
        {
            $$ = $1;
        }
	| COMMAND COMMANDS
        {
            $$ = $1;
            $$->next = $2;
        }
	;

COMMAND
	: TAB WORDLIST NL
        {
            $$ = makecommand($2);
        }
        ;

%%

void
yyerror( char * e )
{
    fprintf(stderr, "error: %d: %s\n", yylineno, e);
    exit( 1 );
}

void
parser_init(struct makefile *mf)
{
    parser_makefile = mf;
}

struct word *
makeword(char *word)
{
    struct word * ret;

    ret = (struct word *) malloc(sizeof(struct word));
    ret->next = NULL;
    ret->word = word;
    return ret;
}

void
printword(struct word *word)
{
    while (word)
    {
        printf("%s", word->word);
        word = word->next;
        if (word)
            printf(" ");
    }
}

struct variable *
makevariable(char *word, struct word *value)
{
    struct variable * ret;
    ret = (struct variable *) malloc( sizeof(struct variable));
    ret->next = NULL;
    ret->variable = word;
    ret->value = value;
    if (value)
    {
        while (value)
        {
            ret->value_next = &value->next;
            value = value->next;
        }
    }
    else
        ret->value_next = &ret->value;
    ret->sum = 0;
    return ret;
}

void
addvarword(struct variable *v, struct word *value)
{
    *v->value_next = value;
    while (value)
    {
        *v->value_next = value->next;
        value = value->next;
    }
}

void
printvariable(struct variable *var, int recurse)
{
    while (var)
    {
        printf("%s ", var->variable);
        if (var->sum)
            printf("+= ");
        else
            printf("= ");
        if (var->value)
            printword(var->value);
        printf("\n");
        if (!recurse)
            break;
        var = var->next;
    }
}

struct command *
makecommand(struct word *words)
{
    struct command * cmd;
    cmd = (struct command *) malloc(sizeof(struct command));
    cmd->next = NULL;
    cmd->command = words;
    if (words)
    {
        while (words)
        {
            cmd->command_next = &words->next;
            words = words->next;
        }
    }
    else
        cmd->command_next = &cmd->command;
    return cmd;
}

void
addcommandword(struct command *cmd, char * word)
{
    struct word * w = makeword(word);
    *cmd->command_next = w;
    cmd->command_next = &w->next;
}

void
printcommand(struct command *command)
{
    while (command)
    {
        printf("\t");
        printword(command->command);
        command = command->next;
        printf("\n");
    }
}

struct rule *
makerule(struct word *targets,
         struct word *sources,
         struct command *commands)
{
    struct rule * ret;
    ret = (struct rule *) malloc( sizeof(struct rule));
    ret->next = NULL;
    ret->targets = targets;
    ret->sources = sources;
    ret->commands = commands;
    return ret;
}

void
printrule(struct rule *rule)
{
    while (rule)
    {
        if (rule->targets)
            printword(rule->targets);
        printf(": ");
        if (rule->sources)
            printword(rule->sources);
        printf("\n");
        if (rule->commands)
        {
            printcommand(rule->commands);
        }
        rule = rule->next;
    }
}

void
printmakefile(struct makefile *makefile)
{
    printvariable(makefile->variables, 1);
    printrule(makefile->rules);
}

struct makefile *
parse_makefile(char *fname)
{
    struct makefile * ret;
    ret = (struct makefile *) malloc( sizeof(struct makefile));
    FILE * in = fopen(fname, "r");
    if (!in)
        return NULL;
    memset(ret, 0, sizeof(parser_makefile));
    ret->variables_next = &ret->variables;
    ret->rules_next = &ret->rules;
    tokenizer_init(in);
    parser_init(ret);
    yyparse();
    parser_makefile = NULL;
    return ret;
}

void
print_tokenized_file(char *fname)
{
    FILE * in = fopen(fname, "r");
    if (!in)
        return;
    tokenizer_init(in);
    while (1)
    {
        int c = yylex();
        printf("got %d (%s)", c, c <= YYMAXTOKEN ? yyname[c] : "");
        if (c == WORD) printf(" (%s)", yylval.word);
        printf("\n");
        if (c <= 0)
            break;
    }
}
