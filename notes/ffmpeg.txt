
ffmpeg \
-i "$infile" \
-strict experimental \
-c:v libx264 \
-preset fast \
-crf $crf \
-c:a aac \
-copyts \
"$outfile"

crf is 18 (perfect) to 28 (not so perfect)
if flv has vp6f and mp3, -c:v libx264 -preset slow -crf $crf -c:a aac
if flv has h264 and aac, use -c copy

ffprobe raw.mov
duration=`ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input"`

---extract video, delete audio

ffmpeg -i raw.mov -strict experimental -c:v copy -an raw-video.mov

---extract video, convert to h264, delete audio

ffmpeg -i raw.mov -strict experimental -c:v libx264 -preset fast -crf 28 -an raw-video.mp4

---extract audio, delete video (keep audio in original aac format)

ffmpeg -i raw.mov -strict experimental -vn -c:a copy raw-audio.aac

---extract audio, delete video (convert to signed 32bit LE WAV)

ffmpeg -i iphone-raw.mov -strict experimental -vn -c:a pcm_s32le iphone-audio.wav

---stupid MTS files from canon camera requires a special filter to make
   good video:

ffmpeg -i $input -strict experimental -c:v libx264 -vf yadif=parity=auto -preset fast -crf 28 -c:a copy -copyts $output

---combining video from one file and audio from another, this assumes
   input video has no audio track at all.

ffmpeg -i video.mp4 -i audio.wav -c:v copy -c:a aac output.mp4

---If your input video already contains audio, and you want to
replace it, you need to tell ffmpeg which audio stream to take:

ffmpeg -i video.mp4 -i audio.wav -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 output.mp4

You can also use "-shortest" to cut the end.

---extract a jpg from a position in the video

output=file.jpg
ffmpeg -y -i "$input" -ss $half_duration -vframes 1 -q:v 2 -s 256x160 $output

--changing frame rate.
ffmpeg -i <input> -filter:v fps=fps=30 <output>




--changing audio sample rate

-ar 48000

--cutting a specific piece out of a file.

startpos=1020
duration=239

-t duration
or
-to position

ffmpeg -i input.mp4 -ss $startpos -t $duration -vcodec copy -acodec copy -y output.mp4
 

ffmpeg -f lavfi -i testsrc=duration=10:size=854x480:rate=60 \
-vf "drawtext=text=%{n}:fontsize=72:r=60:x=(w-tw)/2: y=h-(2*lh):fontcolor=white:box=1:boxcolor=0x00000099" test.mp4

This 10 second, 60 fps video called test.mp4 will show the frame count
at the bottom, and a second counter in the middle of the frame. By
playing the output in a player that allows seeking frame-by-frame, you
can inspect which frames have been dropped or duplicated.


motion interpolation

ffmpeg -i input.mkv -filter:v "minterpolate='mi_mode=mci:mc_mode=aobmc:vsbmc=1:fps=120'" output.mkv

Using a complex filtergraph, you can speed up video and audio at the same time:

ffmpeg -i input.mkv -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2.0[a]" -map "[v]" -map "[a]" output.mkv



change video bitrate

input=output0001-76102.mp4
output=final.mp4
rate=1000k
ffmpeg -i $input -strict experimental -c:v libx264 -x264-params keyint=15 -b:v $rate -c:a copy $output

# args : infile outfile rate
rerate() {
    infile="$1"
    outfile="$2"
    rate="$3"
    keying="-x264-params keyint=15"
    video="-strict experimental -c:v libx264 $keying -b:v $rate"
    audio="-c:a copy"
    ffmpeg -i $infile $video $audio $outfile
}

You can see private options like this: ffmpeg -h encoder=mjpeg.


sometimes you may have to hexedit a WAV
to change 48000 (80 bb) to 44100 (44 ac)'

change audio bitrate

input=
output=
outrate=48000

ffmpeg -i $input -ar $outrate -y $output



make list.txt:

file 'b01.mp4'
file 'b02.mp4'
file 'b03.mp4'
file 'b04.mp4'
file 'b05.mp4'
file 'b06.mp4'

ffmpeg -f concat -i list.txt -c copy -y c.mp4
